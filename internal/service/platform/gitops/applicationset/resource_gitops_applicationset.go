package applicationset

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"

	"github.com/antihax/optional"
	"github.com/harness/harness-go-sdk/harness/nextgen"
	"github.com/harness/terraform-provider-harness/helpers"
	"github.com/harness/terraform-provider-harness/internal"
	"github.com/harness/terraform-provider-harness/internal/service/platform/gitops"
	"github.com/harness/terraform-provider-harness/internal/service/platform/gitops/applications"
	"github.com/harness/terraform-provider-harness/internal/utils"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

const (
	GENERATOR_RESOURCE_SCHEMA_LEVEL_MAX = 3
)

func ResourceGitopsApplicationSet() *schema.Resource {
	return &schema.Resource{
		Description:   "Resource for managing a Harness Gitops Applicationset. Please note this resource is in an alpha/experimental state and is subject to change.",
		SchemaVersion: 0,
		CreateContext: resourceGitopsApplicationsetCreate,
		ReadContext:   resourceGitopsApplicationsetRead,
		UpdateContext: resourceGitopsApplicationsetUpdate,
		DeleteContext: resourceGitopsApplicationsetDelete,
		Importer:      helpers.GitopsAgentApplicationsetImporter,

		CustomizeDiff: func(ctx context.Context, diff *schema.ResourceDiff, i interface{}) error {
			var e error
			if diff.HasChange("project_id") && diff.Id() != "" {
				e = fmt.Errorf("field 'project_id' cannot be changed after the resource is created")
			}
			if diff.HasChange("org_id") && diff.Id() != "" {
				if e != nil {
					e = fmt.Errorf("field 'org_id' cannot be changed after the resource is created:%w", e)
				} else {
					e = fmt.Errorf("field 'org_id' cannot be changed after the resource is created")
				}
			}
			if diff.HasChange("agent_id") && diff.Id() != "" {
				if e != nil {
					e = fmt.Errorf("field 'agent_id' cannot be changed after the resource is created:%v", e)
				} else {
					e = fmt.Errorf("field 'agent_id' cannot be changed after the resource is created")
				}
			}
			if diff.HasChange("applicationset.0.metadata.0.name") && diff.Id() != "" {
				if e != nil {
					e = fmt.Errorf("field 'name' cannot be changed after the resource is created:%w", e)
				} else {
					e = fmt.Errorf("field 'name' cannot be changed after the resource is created")
				}
			}
			return e
		},
		Schema: map[string]*schema.Schema{
			"identifier": {
				Description: "Identifier of the GitOps applicationset. This is a unique identifier for the applicationset generated automatically.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"org_id": {
				Description: "Organization identifier of the GitOps applicationset.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"project_id": {
				Description: "Project identifier of the GitOps applicationset.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"agent_id": {
				Description: "Agent identifier of the GitOps applicationset.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"upsert": {
				Description: "Indicates if the GitOps application should be updated if existing and inserted if not.",
				Type:        schema.TypeBool,
				Optional:    true,
			},
			"applicationset": {
				Description: "Definition of the GitOps applicationset resource.",
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"metadata": {
							Description: "Standard Kubernetes object metadata.",
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Description: "Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.",
										Type:        schema.TypeString,
										Optional:    true,
									},
									"namespace": {
										Description: "Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.",
										Type:        schema.TypeString,
										Optional:    true,
										Computed:    true,
									},
									"generation": {
										Description: "A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.",
										Type:        schema.TypeString,
										Computed:    true,
									},
									"uid": {
										Description: "UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.",
										Type:        schema.TypeString,
										Computed:    true,
									},
									"labels": {
										Description: "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.",
										Type:        schema.TypeMap,
										Optional:    true,
										Computed:    true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"annotations": {
										Description: "Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.",
										Type:        schema.TypeMap,
										Optional:    true,
										Computed:    true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"spec": {
							Description: "Spec of the GitOps applicationset. Includes the generators and template.",
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"generator": {
										Description: "Application set generators are responsible for generation of params, which are then rendered into the template: fields of the ApplicationSet resource.",
										Type:        schema.TypeList,
										Required:    true,
										MinItems:    1,
										Elem:        resourceGenerator(GENERATOR_RESOURCE_SCHEMA_LEVEL_MAX),
									},
									"template": {
										Description: "Application Set template. The template fields of the ApplicationSet spec are used to generate Gitops Applications.",
										Type:        schema.TypeList,
										Required:    true,
										MinItems:    1,
										MaxItems:    1,
										Elem:        resourceApplicationsetTemplate(false),
									},
									"go_template": {
										Description: "Enable Go templating for the template field.",
										Type:        schema.TypeBool,
										Optional:    true,
									},
									"go_template_options": {
										Description: "Optional list of go templating options, see https://pkg.go.dev/text/template#Template.Optional. This is only relevant if `goTemplate` is true",
										Type:        schema.TypeList,
										Optional:    true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"ignore_application_differences": {
										Type:        schema.TypeList,
										Description: "Application Set ignoreApplicationDifferences",
										Optional:    true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"json_pointers": {
													Type:        schema.TypeList,
													Description: "Json pointers to ignore differences",
													Optional:    true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"jq_path_expressions": {
													Type:        schema.TypeList,
													Description: "jq path to ignore differences",
													Optional:    true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"name": {
													Type:        schema.TypeString,
													Description: "name",
													Optional:    true,
												},
											},
										},
									},
									"strategy": {
										Type:        schema.TypeList,
										Description: "[Progressive Sync](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Progressive-Syncs/) strategy",
										Optional:    true,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"type": {
													Type:        schema.TypeString,
													Description: "Type of progressive sync.",
													Required:    true,
												},
												"rolling_sync": {
													Type:        schema.TypeList,
													Description: "Strategy allowing you to group Applications by labels present on the generated Application resources. When the ApplicationSet changes, the changes will be applied to each group of Application resources sequentially.",
													Optional:    true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"step": {
																Type:        schema.TypeList,
																Description: "Configuration used to define which applications to include in each stage of the rolling sync. All Applications in each group must become Healthy before the ApplicationSet controller will proceed to update the next group of Applications.",
																MinItems:    1,
																Required:    true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"match_expressions": matchExpressionsSchema(),
																		"max_update": {
																			Type:         schema.TypeString,
																			Description:  "Maximum number of simultaneous Application updates in a group. Supports both integer and percentage string values (rounds down, but floored at 1 Application for >0%). Default is 100%, unbounded.",
																			ValidateFunc: utils.ValidateIntOrStringPercentage,
																			Optional:     true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"sync_policy": {
										Type:        schema.TypeList,
										Description: "Application Set sync policy",
										Optional:    true,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"preserve_resources_on_deletion": {
													Type:        schema.TypeBool,
													Description: "Label selector used to narrow the scope of targeted clusters.",
													Optional:    true,
												},
												"applications_sync": {
													Type:        schema.TypeString,
													Description: "Represents the policy applied on the generated applications. Possible values are create-only, create-update, create-delete, and sync.",
													Optional:    true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceGitopsApplicationsetCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c, ctx := meta.(*internal.Session).GetPlatformClientWithContext(ctx)

	createAppsetRequest := buildCreateApplicationsetRequest(d)
	var agentIdentifier, orgIdentifier, projectIdentifier string
	if attr, ok := d.GetOk("agent_id"); ok {
		agentIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("org_id"); ok {
		orgIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("project_id"); ok {
		projectIdentifier = attr.(string)
	}
	resp, httpResp, err := c.ApplicationsetApiService.ApplicationSetServiceCreate(ctx, createAppsetRequest, &nextgen.ApplicationSetApiApplicationSetServiceCreateOpts{
		AccountIdentifier: optional.NewString(c.AccountId),
		OrgIdentifier:     optional.NewString(orgIdentifier),
		ProjectIdentifier: optional.NewString(projectIdentifier),
		AgentIdentifier:   optional.NewString(agentIdentifier),
	})
	if err != nil {
		return helpers.HandleApiError(err, d, httpResp)
	}
	// Soft delete lookup error handling
	// https://harness.atlassian.net/browse/PL-23765
	if &resp == nil {
		d.SetId("")
		d.MarkNewResource()
		return nil
	}

	err = setApplicationSet(d, &resp)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceGitopsApplicationsetRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c, ctx := meta.(*internal.Session).GetPlatformClientWithContext(ctx)

	var agentIdentifier, orgIdentifier, projectIdentifier, identifier string
	if attr, ok := d.GetOk("identifier"); ok {
		identifier = attr.(string)
	} else {
		return diag.FromErr(fmt.Errorf("applicationset identifier is missing from terraform state"))
	}
	if attr, ok := d.GetOk("agent_id"); ok {
		agentIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("org_id"); ok {
		orgIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("project_id"); ok {
		projectIdentifier = attr.(string)
	}

	resp, httpResp, err := c.ApplicationsetApiService.ApplicationSetServiceGet(ctx, identifier, &nextgen.ApplicationSetApiApplicationSetServiceGetOpts{
		AccountIdentifier: optional.NewString(c.AccountId),
		OrgIdentifier:     optional.NewString(orgIdentifier),
		ProjectIdentifier: optional.NewString(projectIdentifier),
		AgentIdentifier:   optional.NewString(agentIdentifier),
	})

	if err != nil {
		return helpers.HandleReadApiError(err, d, httpResp)
	}

	// Soft delete lookup error handling
	// https://harness.atlassian.net/browse/PL-23765
	if &resp == nil {
		d.SetId("")
		d.MarkNewResource()
		return nil
	}

	err = setApplicationSet(d, &resp)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceGitopsApplicationsetUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c, ctx := meta.(*internal.Session).GetPlatformClientWithContext(ctx)

	// Proceed with update
	createAppsetRequest := buildCreateApplicationsetRequest(d)
	if attr, ok := d.GetOk("applicationset.0.metadata.0.uid"); ok {
		createAppsetRequest.Applicationset.Metadata.Uid = attr.(string)
	}
	var agentIdentifier, orgIdentifier, projectIdentifier string
	if attr, ok := d.GetOk("agent_id"); ok {
		agentIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("org_id"); ok {
		orgIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("project_id"); ok {
		projectIdentifier = attr.(string)
	}

	// Use the Update API method instead of Create
	resp, httpResp, err := c.ApplicationsetApiService.ApplicationSetServiceUpdate(ctx, createAppsetRequest, &nextgen.ApplicationSetApiApplicationSetServiceUpdateOpts{
		AccountIdentifier: optional.NewString(c.AccountId),
		OrgIdentifier:     optional.NewString(orgIdentifier),
		ProjectIdentifier: optional.NewString(projectIdentifier),
		AgentIdentifier:   optional.NewString(agentIdentifier),
	})

	if err != nil {
		return helpers.HandleApiError(err, d, httpResp)
	}

	// Soft delete lookup error handling
	// https://harness.atlassian.net/browse/PL-23765
	if &resp == nil {
		d.SetId("")
		d.MarkNewResource()
		return nil
	}

	err = setApplicationSet(d, &resp)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceGitopsApplicationsetDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c, ctx := meta.(*internal.Session).GetPlatformClientWithContext(ctx)

	var agentIdentifier, orgIdentifier, projectIdentifier string
	var identifier string = d.Id()

	if attr, ok := d.GetOk("agent_id"); ok {
		agentIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("org_id"); ok {
		orgIdentifier = attr.(string)
	}
	if attr, ok := d.GetOk("project_id"); ok {
		projectIdentifier = attr.(string)
	}

	_, httpResp, err := c.ApplicationsetApiService.ApplicationSetServiceDelete(ctx, identifier, &nextgen.ApplicationSetApiApplicationSetServiceDeleteOpts{
		AccountIdentifier: optional.NewString(c.AccountId),
		OrgIdentifier:     optional.NewString(orgIdentifier),
		ProjectIdentifier: optional.NewString(projectIdentifier),
		AgentIdentifier:   optional.NewString(agentIdentifier),
	})

	if err != nil {
		return helpers.HandleApiError(err, d, httpResp)
	}

	return nil
}

// object builders and flatteners

// setApplicationSet sets the resource data from the ApplicationSet response
func setApplicationSet(d *schema.ResourceData, appset *nextgen.Servicev1ApplicationSet) error {
	d.SetId(appset.Identifier)
	d.Set("identifier", appset.Identifier)
	d.Set("org_id", appset.OrgIdentifier)
	d.Set("project_id", appset.ProjectIdentifier)
	d.Set("agent_id", appset.AgentIdentifier)

	if appset.Appset != nil {
		var applicationsetList = []interface{}{}
		var applicationsetMap = map[string]interface{}{}

		//  metadata
		if appset.Appset.Metadata != nil {
			var metadataList = []interface{}{}
			var metadata = map[string]interface{}{}
			//  set metadata fields
			if appset.Appset.Metadata.Name != "" {
				metadata["name"] = appset.Appset.Metadata.Name
			}
			if appset.Appset.Metadata.Namespace != "" {
				metadata["namespace"] = appset.Appset.Metadata.Namespace
			}
			if appset.Appset.Metadata.Uid != "" {
				metadata["uid"] = appset.Appset.Metadata.Uid
			}
			metadata["generation"] = appset.Appset.Metadata.Generation
			if appset.Appset.Metadata.Labels != nil {
				metadata["labels"] = appset.Appset.Metadata.Labels
			}
			if appset.Appset.Metadata.Annotations != nil {
				metadata["annotations"] = appset.Appset.Metadata.Annotations
			}
			metadataList = append(metadataList, metadata)
			applicationsetMap["metadata"] = metadataList
		}

		if appset.Appset.Spec != nil {
			var specList = []interface{}{}
			var spec = map[string]interface{}{}

			//  go_template
			spec["go_template"] = appset.Appset.Spec.GoTemplate
			spec["go_template_options"] = appset.Appset.Spec.GoTemplateOptions

			//  generators
			if len(appset.Appset.Spec.Generators) > 0 {
				var generatorsList = []interface{}{}
				for _, generator := range appset.Appset.Spec.Generators {
					var generatorMap = map[string]interface{}{}

					//  different generator types
					if generator.List != nil {
						var listMap = map[string]interface{}{}
						// Note: The API returns empty Raw fields for list elements, so we skip reading them
						// and rely on Terraform config as source of truth. This is a known SDK/API limitation.
						if generator.List.Template != nil {
							var templateList = []interface{}{}
							templateList = append(templateList, buildTemplateMapForState(generator.List.Template))
							listMap["template"] = templateList
						}

						if generator.List.Elements != nil && len(generator.List.Elements) > 0 {
							fmt.Printf("DEBUG buildApplicationSet: Found %d elements\n", len(generator.List.Elements))

							var elementsList []interface{}
							for _, elem := range generator.List.Elements {
								fmt.Printf("DEBUG buildApplicationSet: Element: %v\n", elem)
								var elemMap map[string]interface{}
								if err := json.Unmarshal([]byte(elem.Raw), &elemMap); err == nil {
									elementsList = append(elementsList, elemMap)
								}
							}
							if len(elementsList) > 0 {
								listMap["elements"] = elementsList
							}
						}
						generatorMap["list"] = []interface{}{listMap}
					}

					if generator.Clusters != nil {
						var clustersMap = map[string]interface{}{}
						clustersMap["enabled"] = true
						if generator.Clusters.Selector != nil {
							var selectorMap = map[string]interface{}{}
							hasSelector := false
							if generator.Clusters.Selector.MatchLabels != nil && len(generator.Clusters.Selector.MatchLabels) > 0 {
								selectorMap["match_labels"] = generator.Clusters.Selector.MatchLabels
								hasSelector = true
							}
							if len(generator.Clusters.Selector.MatchExpressions) > 0 {
								var expressions []interface{}
								for _, expr := range generator.Clusters.Selector.MatchExpressions {
									expressions = append(expressions, map[string]interface{}{
										"key":      expr.Key,
										"operator": expr.Operator,
										"values":   expr.Values,
									})
								}
								selectorMap["match_expressions"] = expressions
								hasSelector = true
							}
							if hasSelector {
								clustersMap["selector"] = []interface{}{selectorMap}
							}
						}
						if generator.Clusters.Values != nil { //values is map of string string
							var valuesList = []interface{}{}
							for k, v := range generator.Clusters.Values {
								var valueMap = map[string]interface{}{}
								valueMap["key"] = k
								valueMap["value"] = v
								valuesList = append(valuesList, valueMap)
							}
							clustersMap["values"] = valuesList
						}
						if generator.Clusters.Template != nil {
							tmpl := buildTemplateMapForState(generator.Clusters.Template)
							if len(tmpl) > 0 {
								clustersMap["template"] = []interface{}{tmpl}
							}
						}
						generatorMap["clusters"] = []interface{}{clustersMap}
					}

					if generator.Git != nil {
						var gitMap = map[string]interface{}{}
						if generator.Git.RepoURL != "" {
							gitMap["repo_url"] = generator.Git.RepoURL
						}
						if generator.Git.Revision != "" {
							gitMap["revision"] = generator.Git.Revision
						}
						if generator.Git.PathParamPrefix != "" {
							gitMap["path_param_prefix"] = generator.Git.PathParamPrefix
						}
						if generator.Git.Directories != nil {
							var directoriesList = []interface{}{}
							for _, dir := range generator.Git.Directories {
								var directoryMap = map[string]interface{}{}
								if dir.Path != "" {
									directoryMap["path"] = dir.Path
								}
								directoryMap["exclude"] = dir.Exclude
								directoriesList = append(directoriesList, directoryMap)
							}
							gitMap["directory"] = directoriesList
						}
						if generator.Git.Files != nil {
							var filesList = []interface{}{}
							for _, file := range generator.Git.Files {
								var fileMap = map[string]interface{}{}
								if file.Path != "" {
									fileMap["path"] = file.Path
								}
								filesList = append(filesList, fileMap)
							}
							gitMap["file"] = filesList
						}
						if generator.Git.Template != nil {
							tmpl := buildTemplateMapForState(generator.Git.Template)
							if len(tmpl) > 0 {
								gitMap["template"] = []interface{}{tmpl}
							}
						}
						generatorMap["git"] = []interface{}{gitMap}
					}
					// TODO: add less used generators

					generatorsList = append(generatorsList, generatorMap)
				}
				spec["generator"] = generatorsList
			}

			//  template
			if appset.Appset.Spec.Template != nil {
				tmpl := buildTemplateMapForState(appset.Appset.Spec.Template)
				if len(tmpl) > 0 {
					spec["template"] = []interface{}{tmpl}
				}
			}

			specList = append(specList, spec)
			applicationsetMap["spec"] = specList
		}

		applicationsetList = append(applicationsetList, applicationsetMap)
		err := d.Set("applicationset", applicationsetList)
		if err != nil {
			return fmt.Errorf("error setting applicationset: %w", err)
		}
	}

	return nil
}

func buildTemplateMapForState(templ *nextgen.ApplicationsApplicationSetTemplate) map[string]interface{} {
	var template = map[string]interface{}{}

	if templ.Metadata != nil {
		var templateMetadata = map[string]interface{}{}
		tmplMeta := templ.Metadata

		if tmplMeta.Name != "" {
			templateMetadata["name"] = tmplMeta.Name
		}
		if tmplMeta.Namespace != "" {
			templateMetadata["namespace"] = tmplMeta.Namespace
		}
		if len(tmplMeta.Annotations) > 0 {
			templateMetadata["annotations"] = tmplMeta.Annotations
		}
		if len(tmplMeta.Labels) > 0 {
			templateMetadata["labels"] = tmplMeta.Labels
		}

		if len(templateMetadata) > 0 {
			template["metadata"] = []interface{}{templateMetadata}
		}
	}

	//  template spec
	if templ.Spec != nil {
		templateSpec := applications.BuildAppSpecMap(templ.Spec)
		if len(templateSpec) > 0 {
			template["spec"] = []interface{}{templateSpec}
		}
	}
	return template
}

// buildCreateApplicationsetRequest will build the request to create an applicationset. used for update as well
func buildCreateApplicationsetRequest(d *schema.ResourceData) nextgen.ApplicationsApplicationSetCreateRequest {
	var upsert bool
	if attr, ok := d.GetOk("upsert"); ok {
		upsert = attr.(bool)
	}
	return nextgen.ApplicationsApplicationSetCreateRequest{
		Upsert:         upsert,
		Applicationset: buildApplicationSet(d),
	}
}

func buildApplicationSet(d *schema.ResourceData) *nextgen.ApplicationsApplicationSet {
	var appsetMD nextgen.V1ObjectMeta
	var appsetSpec nextgen.ApplicationsApplicationSetSpec

	if attr, ok := d.GetOk("applicationset"); ok && len(attr.([]interface{})) > 0 {
		appset := attr.([]interface{})[0].(map[string]interface{})

		//  metadata
		if meta, ok := appset["metadata"]; ok && len(meta.([]interface{})) > 0 {
			metaData := meta.([]interface{})[0].(map[string]interface{})
			if name, ok := metaData["name"]; ok && len(name.(string)) > 0 {
				appsetMD.Name = name.(string)
			}
			if namespace, ok := metaData["namespace"]; ok && len(namespace.(string)) > 0 {
				appsetMD.Namespace = namespace.(string)
			}
			if labels, ok := metaData["labels"]; ok && len(labels.(map[string]interface{})) > 0 {
				appsetMD.Labels = make(map[string]string)
				for k, v := range labels.(map[string]interface{}) {
					appsetMD.Labels[k] = v.(string)
				}
			}
			if annotations, ok := metaData["annotations"]; ok && len(annotations.(map[string]interface{})) > 0 {
				appsetMD.Annotations = make(map[string]string)
				for k, v := range annotations.(map[string]interface{}) {
					appsetMD.Annotations[k] = v.(string)
				}
			}
		}

		//  spec
		if spec, ok := appset["spec"]; ok && len(spec.([]interface{})) > 0 {
			specData := spec.([]interface{})[0].(map[string]interface{})

			//  GoTemplate
			if goTemplate, ok := specData["go_template"]; ok {
				appsetSpec.GoTemplate = goTemplate.(bool)
			}

			if goTemplateOptions, ok := specData["go_template_options"]; ok {
				opts := make([]string, len(goTemplateOptions.([]interface{})))
				for i, v := range goTemplateOptions.([]interface{}) {
					opts[i] = v.(string)
				}
				appsetSpec.GoTemplateOptions = opts
			}
			//  generators
			if generators, ok := specData["generator"]; ok && len(generators.([]interface{})) > 0 {
				var generatorsList []nextgen.ApplicationsApplicationSetGenerator

				for _, gen := range generators.([]interface{}) {
					generatorMap := gen.(map[string]interface{})
					var generator nextgen.ApplicationsApplicationSetGenerator

					// list generator
					if list, ok := generatorMap["list"]; ok && len(list.([]interface{})) > 0 {
						listData, ok := list.([]interface{})[0].(map[string]interface{})
						if !ok {
							return nil
						}
						var listGen nextgen.ApplicationsListGenerator

						if elements, ok := listData["elements"]; ok && len(elements.([]interface{})) > 0 {
							var elementsList []nextgen.V1Json
							for _, elem := range elements.([]interface{}) {
								elemBytes, _ := json.Marshal(elem)
								// Base64 encode the JSON string as the API expects it
								encoded := base64.StdEncoding.EncodeToString(elemBytes)
								elementsList = append(elementsList, nextgen.V1Json{Raw: encoded})
							}
							listGen.Elements = elementsList
						}

						if template, ok := listData["template"]; ok && len(template.([]interface{})) > 0 {
							templateData := template.([]interface{})[0].(map[string]interface{})
							var appSetTemplate nextgen.ApplicationsApplicationSetTemplate

							if metadata, ok := templateData["metadata"]; ok && len(metadata.([]interface{})) > 0 {
								metaData, ok := metadata.([]interface{})[0].(map[string]interface{})
								if ok {
									var templateMeta nextgen.ApplicationsApplicationSetTemplateMeta
									if name, ok := metaData["name"]; ok && len(name.(string)) > 0 {
										templateMeta.Name = name.(string)
									}
									if namespace, ok := metaData["namespace"]; ok && len(namespace.(string)) > 0 {
										templateMeta.Namespace = namespace.(string)
									}
									if labels, ok := metaData["labels"]; ok && len(labels.(map[string]interface{})) > 0 {
										templateMeta.Labels = make(map[string]string)
										for k, v := range labels.(map[string]interface{}) {
											templateMeta.Labels[k] = v.(string)
										}
									}
									if annotations, ok := metaData["annotations"]; ok && len(annotations.(map[string]interface{})) > 0 {
										templateMeta.Annotations = make(map[string]string)
										for k, v := range annotations.(map[string]interface{}) {
											templateMeta.Annotations[k] = v.(string)
										}
									}
									appSetTemplate.Metadata = &templateMeta
								}
							}

							if spec, ok := templateData["spec"]; ok && len(spec.([]interface{})) > 0 {
								templateSpecData, ok := spec.([]interface{})[0].(map[string]interface{})
								if ok {
									appSpec := applications.BuildApplicationSpecFromMap(templateSpecData)
									appSetTemplate.Spec = &appSpec
								}
							}

							listGen.Template = &appSetTemplate
						}

						generator.List = &listGen
					}

					// clusters generator
					if clusters, ok := generatorMap["clusters"]; ok && len(clusters.([]interface{})) > 0 {
						clustersData, ok := clusters.([]interface{})[0].(map[string]interface{})
						if !ok {
							return nil
						}
						var clustersGen nextgen.ApplicationsClusterGenerator

						if selector, ok := clustersData["selector"]; ok && len(selector.([]interface{})) > 0 {
							selectorData := selector.([]interface{})[0].(map[string]interface{})
							var labelSelector nextgen.V1LabelSelector

							if matchLabels, ok := selectorData["match_labels"]; ok && len(matchLabels.(map[string]interface{})) > 0 {
								labelSelector.MatchLabels = make(map[string]string)
								for k, v := range matchLabels.(map[string]interface{}) {
									labelSelector.MatchLabels[k] = v.(string)
								}
							}

							if matchExpressions, ok := selectorData["match_expressions"]; ok && len(matchExpressions.([]interface{})) > 0 {
								var expressions []nextgen.V1LabelSelectorRequirement
								for _, expr := range matchExpressions.([]interface{}) {
									exprData := expr.(map[string]interface{})
									var requirement nextgen.V1LabelSelectorRequirement

									if key, ok := exprData["key"]; ok && len(key.(string)) > 0 {
										requirement.Key = key.(string)
									}
									if operator, ok := exprData["operator"]; ok && len(operator.(string)) > 0 {
										requirement.Operator = operator.(string)
									}
									if values, ok := exprData["values"]; ok && len(values.([]interface{})) > 0 {
										var valuesList []string
										for _, val := range values.([]interface{}) {
											valuesList = append(valuesList, val.(string))
										}
										requirement.Values = valuesList
									}

									expressions = append(expressions, requirement)
								}
								labelSelector.MatchExpressions = expressions
							}

							clustersGen.Selector = &labelSelector
						}

						if values, ok := clustersData["values"]; ok && len(values.(map[string]interface{})) > 0 {
							clustersGen.Values = make(map[string]string)
							for k, v := range values.(map[string]interface{}) {
								clustersGen.Values[k] = v.(string)
							}
						}

						generator.Clusters = &clustersGen
					}

					// git generator
					if git, ok := generatorMap["git"]; ok && len(git.([]interface{})) > 0 {
						gitData, ok := git.([]interface{})[0].(map[string]interface{})
						if !ok {
							return nil
						}
						var gitGen nextgen.ApplicationsGitGenerator

						if repoURL, ok := gitData["repo_url"]; ok && len(repoURL.(string)) > 0 {
							gitGen.RepoURL = repoURL.(string)
						}

						if revision, ok := gitData["revision"]; ok && len(revision.(string)) > 0 {
							gitGen.Revision = revision.(string)
						}

						if directories, ok := gitData["directory"]; ok && len(directories.([]interface{})) > 0 {
							var dirList []nextgen.ApplicationsGitDirectoryGeneratorItem
							for _, dir := range directories.([]interface{}) {
								dirData := dir.(map[string]interface{})
								var dirItem nextgen.ApplicationsGitDirectoryGeneratorItem

								if path, ok := dirData["path"]; ok && len(path.(string)) > 0 {
									dirItem.Path = path.(string)
								}
								if exclude, ok := dirData["exclude"]; ok {
									dirItem.Exclude = exclude.(bool)
								}

								dirList = append(dirList, dirItem)
							}
							gitGen.Directories = dirList
						}

						if files, ok := gitData["file"]; ok && len(files.([]interface{})) > 0 {
							var fileList []nextgen.ApplicationsGitFileGeneratorItem
							for _, file := range files.([]interface{}) {
								fileData := file.(map[string]interface{})
								var fileItem nextgen.ApplicationsGitFileGeneratorItem

								if path, ok := fileData["path"]; ok && len(path.(string)) > 0 {
									fileItem.Path = path.(string)
								}

								fileList = append(fileList, fileItem)
							}
							gitGen.Files = fileList
						}

						generator.Git = &gitGen
					}
					generatorsList = append(generatorsList, generator)
				}

				appsetSpec.Generators = generatorsList
			}

			if template, ok := specData["template"]; ok && len(template.([]interface{})) > 0 {
				templateData, ok := template.([]interface{})[0].(map[string]interface{})
				if !ok {
					return nil
				}
				var appSetTemplate nextgen.ApplicationsApplicationSetTemplate

				if metadata, ok := templateData["metadata"]; ok && len(metadata.([]interface{})) > 0 {
					metaData, ok := metadata.([]interface{})[0].(map[string]interface{})
					if !ok {
						return nil
					}
					var templateMeta nextgen.ApplicationsApplicationSetTemplateMeta

					if name, ok := metaData["name"]; ok && len(name.(string)) > 0 {
						templateMeta.Name = name.(string)
					}
					if namespace, ok := metaData["namespace"]; ok && len(namespace.(string)) > 0 {
						templateMeta.Namespace = namespace.(string)
					}
					if labels, ok := metaData["labels"]; ok && len(labels.(map[string]interface{})) > 0 {
						templateMeta.Labels = make(map[string]string)
						for k, v := range labels.(map[string]interface{}) {
							templateMeta.Labels[k] = v.(string)
						}
					}
					if annotations, ok := metaData["annotations"]; ok && len(annotations.(map[string]interface{})) > 0 {
						templateMeta.Annotations = make(map[string]string)
						for k, v := range annotations.(map[string]interface{}) {
							templateMeta.Annotations[k] = v.(string)
						}
					}

					appSetTemplate.Metadata = &templateMeta
				}

				if spec, ok := templateData["spec"]; ok && len(spec.([]interface{})) > 0 {
					templateSpecData, ok := spec.([]interface{})[0].(map[string]interface{})
					if !ok {
						return nil
					}
					appSpec := applications.BuildApplicationSpecFromMap(templateSpecData)
					appSetTemplate.Spec = &appSpec
				}

				appsetSpec.Template = &appSetTemplate
			}
		}
	}
	return &nextgen.ApplicationsApplicationSet{
		Metadata: &appsetMD,
		Spec:     &appsetSpec,
	}
}

func resourceGenerator(level int) *schema.Resource {
	if level > 1 {
		return &schema.Resource{
			Schema: map[string]*schema.Schema{
				"cluster_decision_resource": applicationSetClusterDecisionResourceGeneratorSchema(),
				"clusters":                  applicationSetClustersGeneratorSchema(),
				"git":                       applicationSetGitGeneratorSchema(),
				"list":                      applicationSetListGeneratorSchema(),
				"matrix":                    applicationSetMatrixGeneratorSchema(level),
				"merge":                     applicationSetMergeGeneratorSchema(level),
				"pull_request":              applicationSetPullRequestGeneratorSchema(),
				"scm_provider":              applicationSetSCMProviderGeneratorSchema(),
				"selector": {
					Type:        schema.TypeList,
					Description: "The Selector allows to post-filter based on generated values using the kubernetes common labelSelector format.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: labelSelectorSchema(),
					},
				},
			},
		}
	}

	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"cluster_decision_resource": applicationSetClusterDecisionResourceGeneratorSchema(),
			"clusters":                  applicationSetClustersGeneratorSchema(),
			"git":                       applicationSetGitGeneratorSchema(),
			"list":                      applicationSetListGeneratorSchema(),
			"pull_request":              applicationSetPullRequestGeneratorSchema(),
			"scm_provider":              applicationSetSCMProviderGeneratorSchema(),
			"selector": {
				Type:        schema.TypeList,
				Description: "The Selector allows to post-filter based on generated values using the kubernetes common labelSelector format.",
				Optional:    true,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: labelSelectorSchema(),
				},
			},
		},
	}
}

func resourceApplicationsetTemplate(allOptional bool) *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"metadata": {
				Type:        schema.TypeList,
				Description: "Kubernetes object metadata for templated Application.",
				Optional:    allOptional,
				Required:    !allOptional,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"annotations": {
							Type:        schema.TypeMap,
							Description: "An unstructured key value map that may be used to store arbitrary metadata for the resulting Application.",
							Optional:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						"labels": {
							Type:        schema.TypeMap,
							Description: "Map of string keys and values that can be used to organize and categorize (scope and select) the resulting Application.",
							Optional:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						"name": {
							Type:        schema.TypeString,
							Description: "Name of the resulting Application",
							Optional:    allOptional,
							Required:    !allOptional,
						},
						"namespace": {
							Type:        schema.TypeString,
							Description: "Namespace of the resulting Application",
							Optional:    true,
						},
						"finalizers": {
							Type:        schema.TypeList,
							Description: "List of finalizers to apply to the resulting Application.",
							Optional:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"spec": gitops.ArgoAppSpecSchemaV2(allOptional),
		},
	}
}

func resourceSecretRef() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"key": {
				Type:        schema.TypeString,
				Description: "Key containing information in Kubernetes `Secret`.",
				Required:    true,
			},
			"secret_name": {
				Type:        schema.TypeString,
				Description: "Name of Kubernetes `Secret`.",
				Required:    true,
			},
		},
	}
}

// generator schemas
func applicationSetClustersGeneratorSchema() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "The [cluster generator](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Cluster/) produces parameters based on the list of items found within the cluster secret.",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"selector": {
					Type:        schema.TypeList,
					Description: "Label selector used to narrow the scope of targeted clusters.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: labelSelectorSchema(),
					},
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
				"values": {
					Type:        schema.TypeMap,
					Description: "Arbitrary string key-value pairs to pass to the template via the values field of the cluster generator.",
					Optional:    true,
					Elem:        &schema.Schema{Type: schema.TypeString},
				},
				"enabled": {
					Type:        schema.TypeBool,
					Description: "Boolean value defaulting to `true` to indicate that this block has been added thereby allowing all other attributes to be optional.",
					Required:    true,
					DefaultFunc: func() (interface{}, error) { return true, nil },
				},
			},
		},
	}
}

func applicationSetClusterDecisionResourceGeneratorSchema() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "The [cluster decision resource](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Cluster-Decision-Resource/) generates a list of Argo CD clusters.",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"config_map_ref": {
					Type:        schema.TypeString,
					Description: "ConfigMap with the duck type definitions needed to retrieve the data this includes apiVersion(group/version), kind, matchKey and validation settings.",
					Required:    true,
				},
				"name": {
					Type:        schema.TypeString,
					Description: "Resource name of the kind, group and version, defined in the `config_map_ref`.",
					Optional:    true,
				},
				"label_selector": {
					Type:        schema.TypeList,
					Description: "Label selector used to find the resource defined in the `config_map_ref`. Alternative to `name`.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: labelSelectorSchema(),
					},
				},
				"requeue_after_seconds": {
					Type:        schema.TypeString,
					Description: "How often to check for changes (in seconds). Default: 3min.",
					Optional:    true,
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					Computed:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
				"values": {
					Type:        schema.TypeMap,
					Description: "Arbitrary string key-value pairs which are passed directly as parameters to the template.",
					Optional:    true,
					Elem:        &schema.Schema{Type: schema.TypeString},
				},
			},
		},
	}
}

func applicationSetGitGeneratorSchema() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "[Git generators](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Git/) generates parameters using either the directory structure of a specified Git repository (directory generator), or, using the contents of JSON/YAML files found within a specified repository (file generator). ",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"directory": {
					Type:        schema.TypeList,
					Description: "List of directories in the source repository to use when template the Application..",
					Optional:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"path": {
								Type:        schema.TypeString,
								Description: "Path in the repository.",
								Required:    true,
							},
							"exclude": {
								Type:        schema.TypeBool,
								Description: "Flag indicating whether or not the directory should be excluded when templating.",
								Optional:    true,
								Default:     false,
							},
						},
					},
				},
				"file": {
					Type:        schema.TypeList,
					Description: "List of files in the source repository to use when template the Application.",
					Optional:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"path": {
								Type:        schema.TypeString,
								Description: "Path to the file in the repository.",
								Required:    true,
							},
						},
					},
				},
				"repo_url": {
					Type:        schema.TypeString,
					Description: "URL to the repository to use.",
					Required:    true,
				},
				"revision": {
					Type:        schema.TypeString,
					Description: "Revision of the source repository to use.",
					Optional:    true,
				},
				"path_param_prefix": {
					Type:        schema.TypeString,
					Description: "Prefix for all path-related parameter names.",
					Optional:    true,
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					Computed:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
			},
		},
	}
}

func applicationSetListGeneratorSchema() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "[List generators](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-List/) generate parameters based on an arbitrary list of key/value pairs (as long as the values are string values).",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"elements": {
					Type:        schema.TypeList,
					Description: "List of key/value pairs to pass as parameters into the template. Note: Due to API limitations, changes to elements may not be detected.",
					Required:    true,
					Elem: &schema.Schema{
						Type: schema.TypeMap,
						Elem: &schema.Schema{Type: schema.TypeString},
					},
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					Computed:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
			},
		},
	}
}

func applicationSetMatrixGeneratorSchema(level int) *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "[Matrix generators](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Matrix/) combine the parameters generated by two child generators, iterating through every combination of each generator's generated parameters. Take note of the [restrictions](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Matrix/#restrictions) regarding their usage - particularly regarding nesting matrix generators.",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"generator": {
					Type:        schema.TypeList,
					Description: "Child generator. Generators are responsible for generating parameters, which are then combined by the parent matrix generator into the template fields of the ApplicationSet resource.",
					Required:    true,
					MinItems:    2,
					MaxItems:    2,
					Elem:        resourceGenerator(level - 1),
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					Computed:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
			},
		},
	}
}

func applicationSetMergeGeneratorSchema(level int) *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "[Merge generators](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Merge/) combine parameters produced by the base (first) generator with matching parameter sets produced by subsequent generators. Take note of the [restrictions](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Merge/#restrictions) regarding their usage - particularly regarding nesting merge generators.",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"merge_keys": {
					Type:        schema.TypeList,
					Description: "Keys to merge into resulting parameter set.",
					Required:    true,
					Elem:        &schema.Schema{Type: schema.TypeString},
				},
				"generator": {
					Type:        schema.TypeList,
					Description: "Child generator. Generators are responsible for generating parameters, which are then combined by the parent merge generator.",
					Required:    true,
					MinItems:    2,
					Elem:        resourceGenerator(level - 1),
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					Computed:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
			},
		},
	}
}

func applicationSetSCMProviderGeneratorSchema() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "[SCM Provider generators](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-SCM-Provider/) uses the API of an SCMaaS provider to automatically discover repositories within an organization.",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"azure_devops": {
					Type:        schema.TypeList,
					Description: "Uses the Azure DevOps API to look up eligible repositories based on a team project within an Azure DevOps organization.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"all_branches": {
								Type:        schema.TypeBool,
								Description: "Scan all branches instead of just the default branch.",
								Optional:    true,
							},
							"access_token_ref": {
								Type:        schema.TypeList,
								Description: "The Personal Access Token (PAT) to use when connecting.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
							"api": {
								Type:        schema.TypeString,
								Description: "The URL to Azure DevOps. Defaults to https://dev.azure.com.",
								Optional:    true,
							},
							"organization": {
								Type:        schema.TypeString,
								Description: "Azure Devops organization. E.g. \"my-organization\".",
								Required:    true,
							},
							"team_project": {
								Type:        schema.TypeString,
								Description: "Azure Devops team project. E.g. \"my-team\".",
								Required:    true,
							},
						},
					},
				},
				"bitbucket_cloud": {
					Type:        schema.TypeList,
					Description: "Uses the Bitbucket API V2 to scan a workspace in bitbucket.org.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"all_branches": {
								Type:        schema.TypeBool,
								Description: "Scan all branches instead of just the default branch.",
								Optional:    true,
							},
							"app_password_ref": {
								Type:        schema.TypeList,
								Description: "The app password to use for the user. See: https://support.atlassian.com/bitbucket-cloud/docs/app-passwords/.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
							"owner": {
								Type:        schema.TypeString,
								Description: "Bitbucket workspace to scan.",
								Required:    true,
							},
							"user": {
								Type:        schema.TypeString,
								Description: "Bitbucket user to use when authenticating. Should have a \"member\" role to be able to read all repositories and branches.",
								Required:    true,
							},
						},
					},
				},
				"bitbucket_server": {
					Type:        schema.TypeList,
					Description: "Use the Bitbucket Server API (1.0) to scan repos in a project.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"all_branches": {
								Type:        schema.TypeBool,
								Description: "Scan all branches instead of just the default branch.",
								Optional:    true,
							},
							"api": {
								Type:        schema.TypeString,
								Description: "The Bitbucket REST API URL to talk to e.g. https://bitbucket.org/rest.",
								Required:    true,
							},
							"basic_auth": {
								Type:        schema.TypeList,
								Description: "Credentials for Basic auth.",
								Optional:    true,
								MaxItems:    1,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"username": {
											Type:        schema.TypeString,
											Description: "Username for Basic auth.",
											Optional:    true,
										},
										"password_ref": {
											Type:        schema.TypeList,
											Description: "Password (or personal access token) reference.",
											Optional:    true,
											MaxItems:    1,
											Elem:        resourceSecretRef(),
										},
									},
								},
							},
							"project": {
								Type:        schema.TypeString,
								Description: "Project to scan.",
								Required:    true,
							},
						},
					},
				},
				"clone_protocol": {
					Type:        schema.TypeString,
					Description: "Which protocol to use for the SCM URL. Default is provider-specific but ssh if possible. Not all providers necessarily support all protocols.",
					Optional:    true,
				},
				"filter": {
					Type:        schema.TypeList,
					Description: "Filters for which repos should be considered.",
					Optional:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"branch_match": {
								Type:        schema.TypeString,
								Description: "A regex which must match the branch name.",
								Optional:    true,
							},
							"label_match": {
								Type:        schema.TypeString,
								Description: "A regex which must match at least one label.",
								Optional:    true,
							},
							"paths_do_not_exist": {
								Type:        schema.TypeList,
								Description: "An array of paths, all of which must not exist.",
								Optional:    true,
								Elem:        &schema.Schema{Type: schema.TypeString},
							},
							"paths_exist": {
								Type:        schema.TypeList,
								Description: "An array of paths, all of which must exist.",
								Optional:    true,
								Elem:        &schema.Schema{Type: schema.TypeString},
							},
							"repository_match": {
								Type:        schema.TypeString,
								Description: "A regex for repo names.",
								Optional:    true,
							},
						},
					},
				},
				"gitea": {
					Type:        schema.TypeList,
					Description: "Gitea mode uses the Gitea API to scan organizations in your instance.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"all_branches": {
								Type:        schema.TypeBool,
								Description: "Scan all branches instead of just the default branch.",
								Optional:    true,
							},
							"api": {
								Type:        schema.TypeString,
								Description: "The Gitea URL to talk to. For example https://gitea.mydomain.com/.",
								Optional:    true,
							},
							"insecure": {
								Type:        schema.TypeBool,
								Description: "Allow self-signed TLS / Certificates.",
								Optional:    true,
							},
							"owner": {
								Type:        schema.TypeString,
								Description: "Gitea organization or user to scan.",
								Required:    true,
							},
							"token_ref": {
								Type:        schema.TypeList,
								Description: "Authentication token reference.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
						},
					},
				},
				"github": {
					Type:        schema.TypeList,
					Description: "Uses the GitHub API to scan an organization in either github.com or GitHub Enterprise.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"all_branches": {
								Type:        schema.TypeBool,
								Description: "If true, scan every branch of every repository. If false, scan only the default branch.",
								Optional:    true,
							},
							"api": {
								Type:        schema.TypeString,
								Description: "The GitHub API URL to talk to. Default https://api.github.com/.",
								Optional:    true,
							},
							"app_secret_name": {
								Type:        schema.TypeString,
								Description: "Reference to a GitHub App repo-creds secret. Uses a GitHub App to access the API instead of a PAT.",
								Optional:    true,
							},
							"organization": {
								Type:        schema.TypeString,
								Description: "GitHub org to scan.",
								Required:    true,
							},
							"token_ref": {
								Type:        schema.TypeList,
								Description: "Authentication token reference.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
						},
					},
				},
				"gitlab": {
					Type:        schema.TypeList,
					Description: "Uses the GitLab API to scan and organization in either gitlab.com or self-hosted GitLab.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"all_branches": {
								Type:        schema.TypeBool,
								Description: "If true, scan every branch of every repository. If false, scan only the default branch.",
								Optional:    true,
							},
							"api": {
								Type:        schema.TypeString,
								Description: "The Gitlab API URL to talk to.",
								Optional:    true,
							},
							"group": {
								Type:        schema.TypeString,
								Description: "Gitlab group to scan. You can use either the project id (recommended) or the full namespaced path.",
								Required:    true,
							},
							"include_subgroups": {
								Type:        schema.TypeBool,
								Description: "Recurse through subgroups (true) or scan only the base group (false). Defaults to `false`.",
								Optional:    true,
							},
							"token_ref": {
								Type:        schema.TypeList,
								Description: "Authentication token reference.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
						},
					},
				},
				"requeue_after_seconds": {
					Type:        schema.TypeString,
					Description: "How often to check for changes (in seconds). Default: 3min.",
					Optional:    true,
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					Computed:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
			},
		},
	}
}

func applicationSetPullRequestGeneratorSchema() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "[Pull Request generators](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Pull-Request/) uses the API of an SCMaaS provider to automatically discover open pull requests within a repository.",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"bitbucket_server": {
					Type:        schema.TypeList,
					Description: "Fetch pull requests from a repo hosted on a Bitbucket Server.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"api": {
								Type:        schema.TypeString,
								Description: "The Bitbucket REST API URL to talk to e.g. https://bitbucket.org/rest.",
								Required:    true,
							},
							"basic_auth": {
								Type:        schema.TypeList,
								Description: "Credentials for Basic auth.",
								Optional:    true,
								MaxItems:    1,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"username": {
											Type:        schema.TypeString,
											Description: "Username for Basic auth.",
											Optional:    true,
										},
										"password_ref": {
											Type:        schema.TypeList,
											Description: "Password (or personal access token) reference.",
											Optional:    true,
											MaxItems:    1,
											Elem:        resourceSecretRef(),
										},
									},
								},
							},
							"project": {
								Type:        schema.TypeString,
								Description: "Project to scan.",
								Required:    true,
							},
							"repo": {
								Type:        schema.TypeString,
								Description: "Repo name to scan.",
								Required:    true,
							},
						},
					},
				},
				"filter": {
					Type:        schema.TypeList,
					Description: "Filters allow selecting which pull requests to generate for.",
					Optional:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"branch_match": {
								Type:        schema.TypeString,
								Description: "A regex which must match the branch name.",
								Optional:    true,
							},
						},
					},
				},
				"gitea": {
					Type:        schema.TypeList,
					Description: "Specify the repository from which to fetch the Gitea Pull requests.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"api": {
								Type:        schema.TypeString,
								Description: "The Gitea API URL to talk to.",
								Required:    true,
							},
							"insecure": {
								Type:        schema.TypeBool,
								Description: "Allow insecure tls, for self-signed certificates; default: false.",
								Optional:    true,
							},
							"owner": {
								Type:        schema.TypeString,
								Description: "Gitea org or user to scan.",
								Required:    true,
							},
							"repo": {
								Type:        schema.TypeString,
								Description: "Gitea repo name to scan.",
								Required:    true,
							},
							"token_ref": {
								Type:        schema.TypeList,
								Description: "Authentication token reference.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
						},
					},
				},
				"github": {
					Type:        schema.TypeList,
					Description: "Specify the repository from which to fetch the GitHub Pull requests.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"api": {
								Type:        schema.TypeString,
								Description: "The GitHub API URL to talk to. Default https://api.github.com/.",
								Optional:    true,
							},
							"app_secret_name": {
								Type:        schema.TypeString,
								Description: "Reference to a GitHub App repo-creds secret with permission to access pull requests.",
								Optional:    true,
							},
							"labels": {
								Type:        schema.TypeList,
								Description: "Labels is used to filter the PRs that you want to target.",
								Optional:    true,
								Elem:        &schema.Schema{Type: schema.TypeString},
							},
							"owner": {
								Type:        schema.TypeString,
								Description: "GitHub org or user to scan.",
								Required:    true,
							},
							"repo": {
								Type:        schema.TypeString,
								Description: "GitHub repo name to scan.",
								Required:    true,
							},
							"token_ref": {
								Type:        schema.TypeList,
								Description: "Authentication token reference.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
						},
					},
				},
				"gitlab": {
					Type:        schema.TypeList,
					Description: "Specify the project from which to fetch the GitLab merge requests.",
					Optional:    true,
					MaxItems:    1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"api": {
								Type:        schema.TypeString,
								Description: "The GitLab API URL to talk to. If blank, uses https://gitlab.com/.",
								Optional:    true,
							},
							"labels": {
								Type:        schema.TypeList,
								Description: "Labels is used to filter the PRs that you want to target.",
								Optional:    true,
								Elem:        &schema.Schema{Type: schema.TypeString},
							},
							"project": {
								Type:        schema.TypeString,
								Description: "GitLab project to scan.",
								Required:    true,
							},
							"pull_request_state": {
								Type:        schema.TypeString,
								Description: "additional MRs filter to get only those with a certain state. Default:  \"\" (all states).",
								Optional:    true,
							},
							"token_ref": {
								Type:        schema.TypeList,
								Description: "Authentication token reference.",
								Optional:    true,
								MaxItems:    1,
								Elem:        resourceSecretRef(),
							},
						},
					},
				},
				"requeue_after_seconds": {
					Type:        schema.TypeString,
					Description: "How often to check for changes (in seconds). Default: 30min.",
					Optional:    true,
				},
				"template": {
					Type:        schema.TypeList,
					Description: "Generator template. Used to override the values of the spec-level template.",
					Optional:    true,
					MaxItems:    1,
					Elem:        resourceApplicationsetTemplate(true),
				},
			},
		},
	}
}

func labelSelectorSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"match_expressions": matchExpressionsSchema(),
		"match_labels": {
			Type:        schema.TypeMap,
			Description: "A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
			Optional:    true,
		},
	}
}

func matchExpressionsSchema() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Description: "A list of label selector requirements. The requirements are ANDed.",
		Optional:    true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"key": {
					Type:        schema.TypeString,
					Description: "The label key that the selector applies to.",
					Optional:    true,
				},
				"operator": {
					Type:        schema.TypeString,
					Description: "A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.",
					Optional:    true,
				},
				"values": {
					Type:        schema.TypeList,
					Description: "An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.",
					Optional:    true,
					Elem:        &schema.Schema{Type: schema.TypeString},
				},
			},
		},
	}
}
