/*
 * Harness NextGen Software Delivery Platform API Reference
 *
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub
 *
 * API version: 3.0
 * Contact: contact@harness.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nextgen

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type ApplicationsApiService service

/*
ApplicationsApiService Create creates an application
Creates application in project.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceCreateOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "ClusterIdentifier" (optional.String) -
     * @param "RepoIdentifier" (optional.String) -
     * @param "SkipRepoValidation" (optional.Bool) -
     * @param "RepoIdentifiers" (optional.Interface of []string) - 
@return Servicev1Application
*/

type ApplicationsApiAgentApplicationServiceCreateOpts struct {
	AccountIdentifier  optional.String
	OrgIdentifier      optional.String
	ProjectIdentifier  optional.String
	ClusterIdentifier  optional.String
	RepoIdentifier     optional.String
	SkipRepoValidation optional.Bool
    RepoIdentifiers optional.Interface
}

func (a *ApplicationsApiService) AgentApplicationServiceCreate(ctx context.Context, body ApplicationsApplicationCreateRequest, agentIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceCreateOpts) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterIdentifier.IsSet() {
		localVarQueryParams.Add("clusterIdentifier", parameterToString(localVarOptionals.ClusterIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SkipRepoValidation.IsSet() {
		localVarQueryParams.Add("skipRepoValidation", parameterToString(localVarOptionals.SkipRepoValidation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifiers.IsSet() {
		// cast RepoIdentifiers to array of string
		ids := localVarOptionals.RepoIdentifiers.Value().([]string)
		for _, id := range ids {
			localVarQueryParams.Add("repoIdentifiers", parameterToString(id, ""))
		}
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Delete deletes an application
Delete deletes an application.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceDeleteOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "RequestCascade" (optional.Bool) -
     * @param "RequestPropagationPolicy" (optional.String) -
     * @param "OptionsRemoveExistingFinalizers" (optional.Bool) -
@return ApplicationsApplicationResponse
*/

type ApplicationsApiAgentApplicationServiceDeleteOpts struct {
	AccountIdentifier               optional.String
	OrgIdentifier                   optional.String
	ProjectIdentifier               optional.String
	RequestCascade                  optional.Bool
	RequestPropagationPolicy        optional.String
	OptionsRemoveExistingFinalizers optional.Bool
}

func (a *ApplicationsApiService) AgentApplicationServiceDelete(ctx context.Context, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceDeleteOpts) (ApplicationsApplicationResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestCascade.IsSet() {
		localVarQueryParams.Add("request.cascade", parameterToString(localVarOptionals.RequestCascade.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestPropagationPolicy.IsSet() {
		localVarQueryParams.Add("request.propagationPolicy", parameterToString(localVarOptionals.RequestPropagationPolicy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OptionsRemoveExistingFinalizers.IsSet() {
		localVarQueryParams.Add("options.removeExistingFinalizers", parameterToString(localVarOptionals.OptionsRemoveExistingFinalizers.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService DeleteResource deletes a single application resource
DeleteResource deletes a single application resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceDeleteResourceOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "RequestNamespace" (optional.String) -
     * @param "RequestResourceName" (optional.String) -
     * @param "RequestVersion" (optional.String) -
     * @param "RequestGroup" (optional.String) -
     * @param "RequestKind" (optional.String) -
     * @param "RequestForce" (optional.Bool) -
     * @param "RequestOrphan" (optional.Bool) -
@return ApplicationsApplicationResponse
*/

type ApplicationsApiAgentApplicationServiceDeleteResourceOpts struct {
	AccountIdentifier   optional.String
	OrgIdentifier       optional.String
	ProjectIdentifier   optional.String
	RequestNamespace    optional.String
	RequestResourceName optional.String
	RequestVersion      optional.String
	RequestGroup        optional.String
	RequestKind         optional.String
	RequestForce        optional.Bool
	RequestOrphan       optional.Bool
}

func (a *ApplicationsApiService) AgentApplicationServiceDeleteResource(ctx context.Context, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceDeleteResourceOpts) (ApplicationsApplicationResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestNamespace.IsSet() {
		localVarQueryParams.Add("request.namespace", parameterToString(localVarOptionals.RequestNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestResourceName.IsSet() {
		localVarQueryParams.Add("request.resourceName", parameterToString(localVarOptionals.RequestResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestVersion.IsSet() {
		localVarQueryParams.Add("request.version", parameterToString(localVarOptionals.RequestVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestGroup.IsSet() {
		localVarQueryParams.Add("request.group", parameterToString(localVarOptionals.RequestGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestKind.IsSet() {
		localVarQueryParams.Add("request.kind", parameterToString(localVarOptionals.RequestKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestForce.IsSet() {
		localVarQueryParams.Add("request.force", parameterToString(localVarOptionals.RequestForce.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestOrphan.IsSet() {
		localVarQueryParams.Add("request.orphan", parameterToString(localVarOptionals.RequestOrphan.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Get returns an application by name
 Get returns an application by name
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName the application&#x27;s name
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceGetOpts - Optional Parameters:
     * @param "QueryRefresh" (optional.String) -  forces application reconciliation if set to true.
     * @param "QueryProject" (optional.Interface of []string) -  the project names to restrict returned list applications.
     * @param "QueryResourceVersion" (optional.String) -  when specified with a watch call, shows changes that occur after that particular version of a resource.
     * @param "QuerySelector" (optional.String) -  the selector to to restrict returned list to applications only with matched labels.
     * @param "QueryRepo" (optional.String) -  the repoURL to restrict returned list applications.
@return Servicev1Application
*/

type ApplicationsApiAgentApplicationServiceGetOpts struct {
	QueryRefresh         optional.String
	QueryProject         optional.Interface
	QueryResourceVersion optional.String
	QuerySelector        optional.String
	QueryRepo            optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceGet(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceGetOpts) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryRefresh.IsSet() {
		localVarQueryParams.Add("query.refresh", parameterToString(localVarOptionals.QueryRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceVersion.IsSet() {
		localVarQueryParams.Add("query.resourceVersion", parameterToString(localVarOptionals.QueryResourceVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySelector.IsSet() {
		localVarQueryParams.Add("query.selector", parameterToString(localVarOptionals.QuerySelector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Get returns sync windows of the application
GetApplicationSyncWindows returns sync windows of the application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param agentIdentifier Agent identifier for entity.
  - @param queryName
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.

@return ApplicationsApplicationSyncWindowsResponse
*/
func (a *ApplicationsApiService) AgentApplicationServiceGetApplicationSyncWindows(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string) (ApplicationsApplicationSyncWindowsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationSyncWindowsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/syncwindows"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationSyncWindowsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService GetManifests returns application manifests
GetManifests returns application manifests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceGetManifestsOpts - Optional Parameters:
     * @param "QueryRevision" (optional.String) -
@return RepositoriesManifestResponse
*/

type ApplicationsApiAgentApplicationServiceGetManifestsOpts struct {
	QueryRevision optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceGetManifests(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceGetManifestsOpts) (RepositoriesManifestResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesManifestResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/manifests"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryRevision.IsSet() {
		localVarQueryParams.Add("query.revision", parameterToString(localVarOptionals.QueryRevision.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesManifestResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService GetResource returns single application resource
GetResource returns single application resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceGetResourceOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "RequestNamespace" (optional.String) -
     * @param "RequestResourceName" (optional.String) -
     * @param "RequestVersion" (optional.String) -
     * @param "RequestGroup" (optional.String) -
     * @param "RequestKind" (optional.String) -
@return ApplicationsApplicationResourceResponse
*/

type ApplicationsApiAgentApplicationServiceGetResourceOpts struct {
	AccountIdentifier   optional.String
	OrgIdentifier       optional.String
	ProjectIdentifier   optional.String
	RequestNamespace    optional.String
	RequestResourceName optional.String
	RequestVersion      optional.String
	RequestGroup        optional.String
	RequestKind         optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceGetResource(ctx context.Context, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceGetResourceOpts) (ApplicationsApplicationResourceResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResourceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestNamespace.IsSet() {
		localVarQueryParams.Add("request.namespace", parameterToString(localVarOptionals.RequestNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestResourceName.IsSet() {
		localVarQueryParams.Add("request.resourceName", parameterToString(localVarOptionals.RequestResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestVersion.IsSet() {
		localVarQueryParams.Add("request.version", parameterToString(localVarOptionals.RequestVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestGroup.IsSet() {
		localVarQueryParams.Add("request.group", parameterToString(localVarOptionals.RequestGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestKind.IsSet() {
		localVarQueryParams.Add("request.kind", parameterToString(localVarOptionals.RequestKind.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResourceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService List returns list of applications for a specific agent
List returns list of applications for a specific agent.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceListOpts - Optional Parameters:
     * @param "QueryName" (optional.String) -  the application&#x27;s name.
     * @param "QueryRefresh" (optional.String) -  forces application reconciliation if set to true.
     * @param "QueryProject" (optional.Interface of []string) -  the project names to restrict returned list applications.
     * @param "QueryResourceVersion" (optional.String) -  when specified with a watch call, shows changes that occur after that particular version of a resource.
     * @param "QuerySelector" (optional.String) -  the selector to to restrict returned list to applications only with matched labels.
     * @param "QueryRepo" (optional.String) -  the repoURL to restrict returned list applications.
@return ApplicationsApplicationList
*/

type ApplicationsApiAgentApplicationServiceListOpts struct {
	QueryName            optional.String
	QueryRefresh         optional.String
	QueryProject         optional.Interface
	QueryResourceVersion optional.String
	QuerySelector        optional.String
	QueryRepo            optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceList(ctx context.Context, agentIdentifier string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceListOpts) (ApplicationsApplicationList, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryName.IsSet() {
		localVarQueryParams.Add("query.name", parameterToString(localVarOptionals.QueryName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRefresh.IsSet() {
		localVarQueryParams.Add("query.refresh", parameterToString(localVarOptionals.QueryRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceVersion.IsSet() {
		localVarQueryParams.Add("query.resourceVersion", parameterToString(localVarOptionals.QueryResourceVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySelector.IsSet() {
		localVarQueryParams.Add("query.selector", parameterToString(localVarOptionals.QuerySelector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ListResourceActions returns list of resource actions
ListResourceActions returns list of resource actions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceListResourceActionsOpts - Optional Parameters:
     * @param "RequestNamespace" (optional.String) -
     * @param "RequestResourceName" (optional.String) -
     * @param "RequestVersion" (optional.String) -
     * @param "RequestGroup" (optional.String) -
     * @param "RequestKind" (optional.String) -
@return ApplicationsResourceActionsListResponse
*/

type ApplicationsApiAgentApplicationServiceListResourceActionsOpts struct {
	RequestNamespace    optional.String
	RequestResourceName optional.String
	RequestVersion      optional.String
	RequestGroup        optional.String
	RequestKind         optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceListResourceActions(ctx context.Context, agentIdentifier string, requestName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceListResourceActionsOpts) (ApplicationsResourceActionsListResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsResourceActionsListResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.RequestNamespace.IsSet() {
		localVarQueryParams.Add("request.namespace", parameterToString(localVarOptionals.RequestNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestResourceName.IsSet() {
		localVarQueryParams.Add("request.resourceName", parameterToString(localVarOptionals.RequestResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestVersion.IsSet() {
		localVarQueryParams.Add("request.version", parameterToString(localVarOptionals.RequestVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestGroup.IsSet() {
		localVarQueryParams.Add("request.group", parameterToString(localVarOptionals.RequestGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestKind.IsSet() {
		localVarQueryParams.Add("request.kind", parameterToString(localVarOptionals.RequestKind.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsResourceActionsListResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ListResourceEvents returns a list of event resources
ListResourceEvents returns list of event resources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceListResourceEventsOpts - Optional Parameters:
     * @param "QueryResourceNamespace" (optional.String) -
     * @param "QueryResourceName" (optional.String) -
     * @param "QueryResourceUID" (optional.String) -
@return V1EventList
*/

type ApplicationsApiAgentApplicationServiceListResourceEventsOpts struct {
	QueryResourceNamespace optional.String
	QueryResourceName      optional.String
	QueryResourceUID       optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceListResourceEvents(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceListResourceEventsOpts) (V1EventList, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue V1EventList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryResourceNamespace.IsSet() {
		localVarQueryParams.Add("query.resourceNamespace", parameterToString(localVarOptionals.QueryResourceNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceName.IsSet() {
		localVarQueryParams.Add("query.resourceName", parameterToString(localVarOptionals.QueryResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceUID.IsSet() {
		localVarQueryParams.Add("query.resourceUID", parameterToString(localVarOptionals.QueryResourceUID.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v V1EventList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ManagedResources returns list of managed resources
ManagedResources returns list of managed resources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryApplicationName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceManagedResourcesOpts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryName" (optional.String) -
     * @param "QueryVersion" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryKind" (optional.String) -
@return ApplicationsManagedResourcesResponse
*/

type ApplicationsApiAgentApplicationServiceManagedResourcesOpts struct {
	QueryNamespace optional.String
	QueryName      optional.String
	QueryVersion   optional.String
	QueryGroup     optional.String
	QueryKind      optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceManagedResources(ctx context.Context, agentIdentifier string, queryApplicationName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceManagedResourcesOpts) (ApplicationsManagedResourcesResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsManagedResourcesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.applicationName}/managed-resources"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.applicationName"+"}", fmt.Sprintf("%v", queryApplicationName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryName.IsSet() {
		localVarQueryParams.Add("query.name", parameterToString(localVarOptionals.QueryName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryVersion.IsSet() {
		localVarQueryParams.Add("query.version", parameterToString(localVarOptionals.QueryVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsManagedResourcesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Patch patch an application
Patch applys a patches to an application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return Servicev1Application
*/
func (a *ApplicationsApiService) AgentApplicationServicePatch(ctx context.Context, body Servicev1ApplicationPatchRequest, agentIdentifier string, requestName string) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Patch")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService PatchResource patch single application resource
PatchResource patch single application resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServicePatchResourceOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
@return ApplicationsApplicationResourceResponse
*/

type ApplicationsApiAgentApplicationServicePatchResourceOpts struct {
	AccountIdentifier optional.String
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
}

func (a *ApplicationsApiService) AgentApplicationServicePatchResource(ctx context.Context, body ApplicationsApplicationResourcePatchRequest, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServicePatchResourceOpts) (ApplicationsApplicationResourceResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResourceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResourceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService PodLogs returns stream of log entries for the specified pod(s).
PodLogs returns stream of log entries for the specified pod(s).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param queryPodName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServicePodLogsOpts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryContainer" (optional.String) -
     * @param "QuerySinceSeconds" (optional.String) -
     * @param "QuerySinceTimeSeconds" (optional.String) -  Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @param "QuerySinceTimeNanos" (optional.Int32) -  Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @param "QueryTailLines" (optional.String) -
     * @param "QueryFollow" (optional.Bool) -
     * @param "QueryUntilTime" (optional.String) -
     * @param "QueryFilter" (optional.String) -
     * @param "QueryKind" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryResourceName" (optional.String) -
     * @param "QueryPrevious" (optional.Bool) -
@return StreamResultOfApplicationsLogEntry
*/

type ApplicationsApiAgentApplicationServicePodLogsOpts struct {
	QueryNamespace        optional.String
	QueryContainer        optional.String
	QuerySinceSeconds     optional.String
	QuerySinceTimeSeconds optional.String
	QuerySinceTimeNanos   optional.Int32
	QueryTailLines        optional.String
	QueryFollow           optional.Bool
	QueryUntilTime        optional.String
	QueryFilter           optional.String
	QueryKind             optional.String
	QueryGroup            optional.String
	QueryResourceName     optional.String
	QueryPrevious         optional.Bool
}

func (a *ApplicationsApiService) AgentApplicationServicePodLogs(ctx context.Context, agentIdentifier string, queryName string, queryPodName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServicePodLogsOpts) (StreamResultOfApplicationsLogEntry, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsLogEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/pods/{query.podName}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.podName"+"}", fmt.Sprintf("%v", queryPodName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryContainer.IsSet() {
		localVarQueryParams.Add("query.container", parameterToString(localVarOptionals.QueryContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceSeconds", parameterToString(localVarOptionals.QuerySinceSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceTime.seconds", parameterToString(localVarOptionals.QuerySinceTimeSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeNanos.IsSet() {
		localVarQueryParams.Add("query.sinceTime.nanos", parameterToString(localVarOptionals.QuerySinceTimeNanos.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryTailLines.IsSet() {
		localVarQueryParams.Add("query.tailLines", parameterToString(localVarOptionals.QueryTailLines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFollow.IsSet() {
		localVarQueryParams.Add("query.follow", parameterToString(localVarOptionals.QueryFollow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryUntilTime.IsSet() {
		localVarQueryParams.Add("query.untilTime", parameterToString(localVarOptionals.QueryUntilTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFilter.IsSet() {
		localVarQueryParams.Add("query.filter", parameterToString(localVarOptionals.QueryFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceName.IsSet() {
		localVarQueryParams.Add("query.resourceName", parameterToString(localVarOptionals.QueryResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryPrevious.IsSet() {
		localVarQueryParams.Add("query.previous", parameterToString(localVarOptionals.QueryPrevious.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsLogEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService PodLogs returns stream of log entries for the specified pod(s).
PodLogs returns stream of log entries for the specified pod(s).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServicePodLogs2Opts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryPodName" (optional.String) -
     * @param "QueryContainer" (optional.String) -
     * @param "QuerySinceSeconds" (optional.String) -
     * @param "QuerySinceTimeSeconds" (optional.String) -  Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @param "QuerySinceTimeNanos" (optional.Int32) -  Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @param "QueryTailLines" (optional.String) -
     * @param "QueryFollow" (optional.Bool) -
     * @param "QueryUntilTime" (optional.String) -
     * @param "QueryFilter" (optional.String) -
     * @param "QueryKind" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryResourceName" (optional.String) -
     * @param "QueryPrevious" (optional.Bool) -
@return StreamResultOfApplicationsLogEntry
*/

type ApplicationsApiAgentApplicationServicePodLogs2Opts struct {
	QueryNamespace        optional.String
	QueryPodName          optional.String
	QueryContainer        optional.String
	QuerySinceSeconds     optional.String
	QuerySinceTimeSeconds optional.String
	QuerySinceTimeNanos   optional.Int32
	QueryTailLines        optional.String
	QueryFollow           optional.Bool
	QueryUntilTime        optional.String
	QueryFilter           optional.String
	QueryKind             optional.String
	QueryGroup            optional.String
	QueryResourceName     optional.String
	QueryPrevious         optional.Bool
}

func (a *ApplicationsApiService) AgentApplicationServicePodLogs2(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServicePodLogs2Opts) (StreamResultOfApplicationsLogEntry, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsLogEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryPodName.IsSet() {
		localVarQueryParams.Add("query.podName", parameterToString(localVarOptionals.QueryPodName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryContainer.IsSet() {
		localVarQueryParams.Add("query.container", parameterToString(localVarOptionals.QueryContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceSeconds", parameterToString(localVarOptionals.QuerySinceSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceTime.seconds", parameterToString(localVarOptionals.QuerySinceTimeSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeNanos.IsSet() {
		localVarQueryParams.Add("query.sinceTime.nanos", parameterToString(localVarOptionals.QuerySinceTimeNanos.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryTailLines.IsSet() {
		localVarQueryParams.Add("query.tailLines", parameterToString(localVarOptionals.QueryTailLines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFollow.IsSet() {
		localVarQueryParams.Add("query.follow", parameterToString(localVarOptionals.QueryFollow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryUntilTime.IsSet() {
		localVarQueryParams.Add("query.untilTime", parameterToString(localVarOptionals.QueryUntilTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFilter.IsSet() {
		localVarQueryParams.Add("query.filter", parameterToString(localVarOptionals.QueryFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceName.IsSet() {
		localVarQueryParams.Add("query.resourceName", parameterToString(localVarOptionals.QueryResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryPrevious.IsSet() {
		localVarQueryParams.Add("query.previous", parameterToString(localVarOptionals.QueryPrevious.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsLogEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ResourceTree returns resource tree
ResourceTree returns resource tree.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceResourceTreeOpts - Optional Parameters:
     * @param "QueryApplicationName" (optional.String) -
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryVersion" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryKind" (optional.String) -
@return ApplicationsApplicationTree
*/

type ApplicationsApiAgentApplicationServiceResourceTreeOpts struct {
	QueryApplicationName optional.String
	QueryNamespace       optional.String
	QueryVersion         optional.String
	QueryGroup           optional.String
	QueryKind            optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceResourceTree(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceResourceTreeOpts) (ApplicationsApplicationTree, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationTree
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryApplicationName.IsSet() {
		localVarQueryParams.Add("query.applicationName", parameterToString(localVarOptionals.QueryApplicationName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryVersion.IsSet() {
		localVarQueryParams.Add("query.version", parameterToString(localVarOptionals.QueryVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationTree
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Get the meta-data (author, date, tags, message) for a specific revision of the application
RevisionMetadata returns metadata for a specific revision of the application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param agentIdentifier Agent identifier for entity.
  - @param queryName the application&#x27;s name
  - @param queryRevision the revision of the app
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.

@return RepositoriesRevisionMetadata
*/
func (a *ApplicationsApiService) AgentApplicationServiceRevisionMetadata(ctx context.Context, agentIdentifier string, queryName string, queryRevision string, accountIdentifier string, orgIdentifier string, projectIdentifier string) (RepositoriesRevisionMetadata, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesRevisionMetadata
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/revisions/{query.revision}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.revision"+"}", fmt.Sprintf("%v", queryRevision), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesRevisionMetadata
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Rollback syncs an application to its target state Harness Event type (rollback)
Rollback syncs an application to its target state Harness Event type (rollback).
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return Servicev1Application
*/
func (a *ApplicationsApiService) AgentApplicationServiceRollback(ctx context.Context, body ApplicationsApplicationRollbackRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestName string) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService RunResourceAction run resource action
RunResourceAction run resource action.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceRunResourceActionOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
@return ApplicationsApplicationResponse
*/

type ApplicationsApiAgentApplicationServiceRunResourceActionOpts struct {
	AccountIdentifier optional.String
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceRunResourceAction(ctx context.Context, body ApplicationsResourceActionRunRequest, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceRunResourceActionOpts) (ApplicationsApplicationResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Sync syncs an application to its target state Harness Event type (deploy)
Delete deletes an application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return Servicev1Application
*/
func (a *ApplicationsApiService) AgentApplicationServiceSync(ctx context.Context, body ApplicationsApplicationSyncRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestName string) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService TerminateOperation terminates the currently running operation
TerminateOperation terminates the currently running operation.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.

@return ApplicationsOperationTerminateResponse
*/
func (a *ApplicationsApiService) AgentApplicationServiceTerminateOperation(ctx context.Context, agentIdentifier string, requestName string, accountIdentifier string, orgIdentifier string, projectIdentifier string) (ApplicationsOperationTerminateResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsOperationTerminateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/operation"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsOperationTerminateResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Update updates an application
Update updates an application.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param agentIdentifier Agent identifier for entity.
 * @param requestApplicationMetadataName Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
 * @param optional nil or *ApplicationsApiAgentApplicationServiceUpdateOpts - Optional Parameters:
     * @param "ClusterIdentifier" (optional.String) -
     * @param "RepoIdentifier" (optional.String) -
     * @param "SkipRepoValidation" (optional.Bool) -
     * @param "RepoIdentifiers" (optional.Interface of []string) - 
@return Servicev1Application
*/

type ApplicationsApiAgentApplicationServiceUpdateOpts struct {
    ClusterIdentifier optional.String
    RepoIdentifier optional.String
    SkipRepoValidation optional.Bool
    RepoIdentifiers optional.Interface
}


func (a *ApplicationsApiService) AgentApplicationServiceUpdate(ctx context.Context, body ApplicationsApplicationUpdateRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestApplicationMetadataName string, localVarOptionals *ApplicationsApiAgentApplicationServiceUpdateOpts) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.application.metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.application.metadata.name"+"}", fmt.Sprintf("%v", requestApplicationMetadataName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.ClusterIdentifier.IsSet() {
		localVarQueryParams.Add("clusterIdentifier", parameterToString(localVarOptionals.ClusterIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SkipRepoValidation.IsSet() {
		localVarQueryParams.Add("skipRepoValidation", parameterToString(localVarOptionals.SkipRepoValidation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifiers.IsSet() {
		// cast RepoIdentifiers to array of string
		ids := localVarOptionals.RepoIdentifiers.Value().([]string)
		for _, id := range ids {
			localVarQueryParams.Add("repoIdentifiers", parameterToString(id, ""))
		}
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService UpdateSpec updates an application spec
UpdateSpec updates an application spec.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return ApplicationsApplicationSpec
*/
func (a *ApplicationsApiService) AgentApplicationServiceUpdateSpec(ctx context.Context, body ApplicationsApplicationUpdateSpecRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestName string) (ApplicationsApplicationSpec, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationSpec
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/spec"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationSpec
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Watch returns stream of application change events
Watch returns stream of application change events.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param queryName the application&#x27;s name.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceWatchOpts - Optional Parameters:
     * @param "QueryRefresh" (optional.String) -  forces application reconciliation if set to true.
     * @param "QueryProject" (optional.Interface of []string) -  the project names to restrict returned list applications.
     * @param "QueryResourceVersion" (optional.String) -  when specified with a watch call, shows changes that occur after that particular version of a resource.
     * @param "QuerySelector" (optional.String) -  the selector to to restrict returned list to applications only with matched labels.
     * @param "QueryRepo" (optional.String) -  the repoURL to restrict returned list applications.
@return StreamResultOfApplicationsApplicationWatchEvent
*/

type ApplicationsApiAgentApplicationServiceWatchOpts struct {
	QueryRefresh         optional.String
	QueryProject         optional.Interface
	QueryResourceVersion optional.String
	QuerySelector        optional.String
	QueryRepo            optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceWatch(ctx context.Context, agentIdentifier string, accountIdentifier string, orgIdentifier string, projectIdentifier string, queryName string, localVarOptionals *ApplicationsApiAgentApplicationServiceWatchOpts) (StreamResultOfApplicationsApplicationWatchEvent, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsApplicationWatchEvent
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/stream/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("query.name", parameterToString(queryName, ""))
	if localVarOptionals != nil && localVarOptionals.QueryRefresh.IsSet() {
		localVarQueryParams.Add("query.refresh", parameterToString(localVarOptionals.QueryRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceVersion.IsSet() {
		localVarQueryParams.Add("query.resourceVersion", parameterToString(localVarOptionals.QueryResourceVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySelector.IsSet() {
		localVarQueryParams.Add("query.selector", parameterToString(localVarOptionals.QuerySelector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsApplicationWatchEvent
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService WatchResourceTree returns stream of application resource tree
WatchResourceTree returns stream of application resource tree.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryApplicationName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceWatchResourceTreeOpts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryName" (optional.String) -
     * @param "QueryVersion" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryKind" (optional.String) -
@return StreamResultOfApplicationsApplicationTree
*/

type ApplicationsApiAgentApplicationServiceWatchResourceTreeOpts struct {
	QueryNamespace optional.String
	QueryName      optional.String
	QueryVersion   optional.String
	QueryGroup     optional.String
	QueryKind      optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceWatchResourceTree(ctx context.Context, agentIdentifier string, queryApplicationName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceWatchResourceTreeOpts) (StreamResultOfApplicationsApplicationTree, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsApplicationTree
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/stream/applications/{query.applicationName}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.applicationName"+"}", fmt.Sprintf("%v", queryApplicationName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryName.IsSet() {
		localVarQueryParams.Add("query.name", parameterToString(localVarOptionals.QueryName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryVersion.IsSet() {
		localVarQueryParams.Add("query.version", parameterToString(localVarOptionals.QueryVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsApplicationTree
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Checks whether an app with the given name exists
Checks whether an app with the given name exists
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiApplicationServiceExistsOpts - Optional Parameters:
     * @param "AgentIdentifier" (optional.String) -  Agent identifier for entity.
@return bool
*/

type ApplicationsApiApplicationServiceExistsOpts struct {
	AgentIdentifier optional.String
}

func (a *ApplicationsApiService) ApplicationServiceExists(ctx context.Context, name string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiApplicationServiceExistsOpts) (bool, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue bool
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/applications/{name}/exists"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.AgentIdentifier.IsSet() {
		localVarQueryParams.Add("agentIdentifier", parameterToString(localVarOptionals.AgentIdentifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v bool
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService List returns list of application sync status
List returns list of application sync status
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body

@return V1ApplicationSyncStatuslist
*/
func (a *ApplicationsApiService) ApplicationServiceListAppSync(ctx context.Context, body V1ApplicationSyncStatusQuery) (V1ApplicationSyncStatuslist, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue V1ApplicationSyncStatuslist
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/applications/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v V1ApplicationSyncStatuslist
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
