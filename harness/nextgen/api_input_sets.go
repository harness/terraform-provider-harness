/*
 * CD NextGen API Reference
 *
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * API version: 3.0
 * Contact: contact@harness.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nextgen

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type InputSetsApiService service

/*
InputSetsApiService Delete the Input Set by Identifier
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param inputSetIdentifier This is the Id of the Input Set that needs to be deleted. An error is thrown if no Input Set exists for this Id.
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline identifier for the Input Set. Input Set will be deleted for the Pipeline corresponding to this Identifier
 * @param optional nil or *InputSetsApiDeleteInputSetOpts - Optional Parameters:
     * @param "IfMatch" (optional.String) -  Version of entity to match
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "RootFolder" (optional.String) -  Default Folder Path
     * @param "FilePath" (optional.String) -  File Path
     * @param "CommitMsg" (optional.String) -  Commit Message
     * @param "LastObjectId" (optional.String) -  Last Object Id
@return ResponseDtoBoolean
*/

type InputSetsApiDeleteInputSetOpts struct {
	IfMatch        optional.String
	Branch         optional.String
	RepoIdentifier optional.String
	RootFolder     optional.String
	FilePath       optional.String
	CommitMsg      optional.String
	LastObjectId   optional.String
}

func (a *InputSetsApiService) DeleteInputSet(ctx context.Context, inputSetIdentifier string, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiDeleteInputSetOpts) (ResponseDtoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/{inputSetIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"inputSetIdentifier"+"}", fmt.Sprintf("%v", inputSetIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RootFolder.IsSet() {
		localVarQueryParams.Add("rootFolder", parameterToString(localVarOptionals.RootFolder.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilePath.IsSet() {
		localVarQueryParams.Add("filePath", parameterToString(localVarOptionals.FilePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CommitMsg.IsSet() {
		localVarQueryParams.Add("commitMsg", parameterToString(localVarOptionals.CommitMsg.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastObjectId.IsSet() {
		localVarQueryParams.Add("lastObjectId", parameterToString(localVarOptionals.LastObjectId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoBoolean
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Gets Input Set for a given identifier. Throws error if no Input Set exists for the given identifier.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param inputSetIdentifier Identifier of the Input Set
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline ID for the Input Set. The Input Set will work only for the Pipeline corresponding to this identifier.
 * @param optional nil or *InputSetsApiGetInputSetOpts - Optional Parameters:
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "GetDefaultFromOtherRepo" (optional.Bool) -  if true, return all the default entities
@return ResponseDtoInputSetResponse
*/

type InputSetsApiGetInputSetOpts struct {
	Branch                  optional.String
	RepoIdentifier          optional.String
	GetDefaultFromOtherRepo optional.Bool
}

func (a *InputSetsApiService) GetInputSet(ctx context.Context, inputSetIdentifier string, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiGetInputSetOpts) (ResponseDtoInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/{inputSetIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"inputSetIdentifier"+"}", fmt.Sprintf("%v", inputSetIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetDefaultFromOtherRepo.IsSet() {
		localVarQueryParams.Add("getDefaultFromOtherRepo", parameterToString(localVarOptionals.GetDefaultFromOtherRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Gets an Overlay Input Set by identifier
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param inputSetIdentifier Identifier of the Overlay Input Set
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier This is the Pipeline Id specific to the Overlay Input Set. Overlay Input Set corresponding to the Pipeline with this Id would be fetched
 * @param optional nil or *InputSetsApiGetOverlayInputSetOpts - Optional Parameters:
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "GetDefaultFromOtherRepo" (optional.Bool) -  if true, return all the default entities
@return ResponseDtoOverlayInputSetResponse
*/

type InputSetsApiGetOverlayInputSetOpts struct {
	Branch                  optional.String
	RepoIdentifier          optional.String
	GetDefaultFromOtherRepo optional.Bool
}

func (a *InputSetsApiService) GetOverlayInputSet(ctx context.Context, inputSetIdentifier string, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiGetOverlayInputSetOpts) (ResponseDtoOverlayInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoOverlayInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/overlay/{inputSetIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"inputSetIdentifier"+"}", fmt.Sprintf("%v", inputSetIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetDefaultFromOtherRepo.IsSet() {
		localVarQueryParams.Add("getDefaultFromOtherRepo", parameterToString(localVarOptionals.GetDefaultFromOtherRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoOverlayInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService List all Input Sets for a pipeline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline identifier for which we need the Input Sets list.
 * @param optional nil or *InputSetsApiListInputSetOpts - Optional Parameters:
     * @param "PageIndex" (optional.Int32) -  The number of the page to fetch
     * @param "PageSize" (optional.Int32) -  The number of the elements to fetch
     * @param "InputSetType" (optional.String) -  Type of Input Set needed: \&quot;INPUT_SET\&quot;, or \&quot;OVERLAY_INPUT_SET\&quot;, or \&quot;ALL\&quot;. If nothing is sent, ALL is considered.
     * @param "SearchTerm" (optional.String) -  Search term to filter out Input Sets based on name, identifier, tags.
     * @param "SortOrders" (optional.Interface of []string) -  Sort criteria for the elements.
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "GetDefaultFromOtherRepo" (optional.Bool) -  if true, return all the default entities
@return ResponseDtoPageResponseInputSetSummaryResponse
*/

type InputSetsApiListInputSetOpts struct {
	PageIndex               optional.Int32
	PageSize                optional.Int32
	InputSetType            optional.String
	SearchTerm              optional.String
	SortOrders              optional.Interface
	Branch                  optional.String
	RepoIdentifier          optional.String
	GetDefaultFromOtherRepo optional.Bool
}

func (a *InputSetsApiService) ListInputSet(ctx context.Context, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiListInputSetOpts) (ResponseDtoPageResponseInputSetSummaryResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoPageResponseInputSetSummaryResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.InputSetType.IsSet() {
		localVarQueryParams.Add("inputSetType", parameterToString(localVarOptionals.InputSetType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchTerm.IsSet() {
		localVarQueryParams.Add("searchTerm", parameterToString(localVarOptionals.SearchTerm.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortOrders.IsSet() {
		localVarQueryParams.Add("sortOrders", parameterToString(localVarOptionals.SortOrders.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetDefaultFromOtherRepo.IsSet() {
		localVarQueryParams.Add("getDefaultFromOtherRepo", parameterToString(localVarOptionals.GetDefaultFromOtherRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoPageResponseInputSetSummaryResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Merge given Input Sets into a single Runtime Input YAML
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Identifier of the Pipeline to which the Input Sets belong
 * @param optional nil or *InputSetsApiMergeInputSetsOpts - Optional Parameters:
     * @param "PipelineBranch" (optional.String) -  Github branch of the Pipeline to which the Input Sets belong
     * @param "PipelineRepoID" (optional.String) -  Github Repo identifier of the Pipeline to which the Input Sets belong
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "GetDefaultFromOtherRepo" (optional.Bool) -  if true, return all the default entities
@return ResponseDtoMergeInputSetResponse
*/

type InputSetsApiMergeInputSetsOpts struct {
	PipelineBranch          optional.String
	PipelineRepoID          optional.String
	Branch                  optional.String
	RepoIdentifier          optional.String
	GetDefaultFromOtherRepo optional.Bool
}

func (a *InputSetsApiService) MergeInputSets(ctx context.Context, body MergeInputSetRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiMergeInputSetsOpts) (ResponseDtoMergeInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoMergeInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/merge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.PipelineBranch.IsSet() {
		localVarQueryParams.Add("pipelineBranch", parameterToString(localVarOptionals.PipelineBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PipelineRepoID.IsSet() {
		localVarQueryParams.Add("pipelineRepoID", parameterToString(localVarOptionals.PipelineRepoID.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetDefaultFromOtherRepo.IsSet() {
		localVarQueryParams.Add("getDefaultFromOtherRepo", parameterToString(localVarOptionals.GetDefaultFromOtherRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoMergeInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Merge given Runtime Input YAML into the Pipeline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Identifier of the Pipeline to which the Input Sets belong
 * @param optional nil or *InputSetsApiMergeRuntimeInputIntoPipelineOpts - Optional Parameters:
     * @param "PipelineBranch" (optional.String) -  Github branch of the Pipeline to which the Input Sets belong
     * @param "PipelineRepoID" (optional.String) -  Github Repo identifier of the Pipeline to which the Input Sets belong
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "GetDefaultFromOtherRepo" (optional.Bool) -  if true, return all the default entities
@return ResponseDtoMergeInputSetResponse
*/

type InputSetsApiMergeRuntimeInputIntoPipelineOpts struct {
	PipelineBranch          optional.String
	PipelineRepoID          optional.String
	Branch                  optional.String
	RepoIdentifier          optional.String
	GetDefaultFromOtherRepo optional.Bool
}

func (a *InputSetsApiService) MergeRuntimeInputIntoPipeline(ctx context.Context, body MergeInputSetTemplateRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiMergeRuntimeInputIntoPipelineOpts) (ResponseDtoMergeInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoMergeInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/mergeWithTemplateYaml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.PipelineBranch.IsSet() {
		localVarQueryParams.Add("pipelineBranch", parameterToString(localVarOptionals.PipelineBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PipelineRepoID.IsSet() {
		localVarQueryParams.Add("pipelineRepoID", parameterToString(localVarOptionals.PipelineRepoID.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetDefaultFromOtherRepo.IsSet() {
		localVarQueryParams.Add("getDefaultFromOtherRepo", parameterToString(localVarOptionals.GetDefaultFromOtherRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoMergeInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Create an Input Set for a Pipeline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Input set YAML to be created. The account, org, project, and pipeline identifiers inside the YAML should match the query parameters
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline identifier for the input set. The input set will work only for the pipeline corresponding to this identifier.
 * @param optional nil or *InputSetsApiPostInputSetOpts - Optional Parameters:
     * @param "PipelineBranch" (optional.String) -  Github branch of the Pipeline for which the Input Set is to be created
     * @param "PipelineRepoID" (optional.String) -  Github Repo identifier of the Pipeline for which the Input Set is to be created
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "RootFolder" (optional.String) -  Default Folder Path
     * @param "FilePath" (optional.String) -  File Path
     * @param "CommitMsg" (optional.String) -  File Path
     * @param "IsNewBranch" (optional.Bool) -  Checks the new branch
     * @param "BaseBranch" (optional.String) -  Default Branch
@return ResponseDtoInputSetResponse
*/

type InputSetsApiPostInputSetOpts struct {
	PipelineBranch optional.String
	PipelineRepoID optional.String
	Branch         optional.String
	RepoIdentifier optional.String
	RootFolder     optional.String
	FilePath       optional.String
	CommitMsg      optional.String
	IsNewBranch    optional.Bool
	BaseBranch     optional.String
}

func (a *InputSetsApiService) PostInputSet(ctx context.Context, body string, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiPostInputSetOpts) (ResponseDtoInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.PipelineBranch.IsSet() {
		localVarQueryParams.Add("pipelineBranch", parameterToString(localVarOptionals.PipelineBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PipelineRepoID.IsSet() {
		localVarQueryParams.Add("pipelineRepoID", parameterToString(localVarOptionals.PipelineRepoID.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RootFolder.IsSet() {
		localVarQueryParams.Add("rootFolder", parameterToString(localVarOptionals.RootFolder.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilePath.IsSet() {
		localVarQueryParams.Add("filePath", parameterToString(localVarOptionals.FilePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CommitMsg.IsSet() {
		localVarQueryParams.Add("commitMsg", parameterToString(localVarOptionals.CommitMsg.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsNewBranch.IsSet() {
		localVarQueryParams.Add("isNewBranch", parameterToString(localVarOptionals.IsNewBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaseBranch.IsSet() {
		localVarQueryParams.Add("baseBranch", parameterToString(localVarOptionals.BaseBranch.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Create an Overlay Input Set for a pipeline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Overlay Input Set YAML to be created. The Account, Org, Project, and Pipeline identifiers inside the YAML should match the query parameters
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline identifier for the overlay input set. The Overlay Input Set will work only for the Pipeline corresponding to this identifier.
 * @param optional nil or *InputSetsApiPostOverlayInputSetOpts - Optional Parameters:
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "RootFolder" (optional.String) -  Default Folder Path
     * @param "FilePath" (optional.String) -  File Path
     * @param "CommitMsg" (optional.String) -  File Path
     * @param "IsNewBranch" (optional.Bool) -  Checks the new branch
     * @param "BaseBranch" (optional.String) -  Default Branch
@return ResponseDtoOverlayInputSetResponse
*/

type InputSetsApiPostOverlayInputSetOpts struct {
	Branch         optional.String
	RepoIdentifier optional.String
	RootFolder     optional.String
	FilePath       optional.String
	CommitMsg      optional.String
	IsNewBranch    optional.Bool
	BaseBranch     optional.String
}

func (a *InputSetsApiService) PostOverlayInputSet(ctx context.Context, body string, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiPostOverlayInputSetOpts) (ResponseDtoOverlayInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoOverlayInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/overlay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RootFolder.IsSet() {
		localVarQueryParams.Add("rootFolder", parameterToString(localVarOptionals.RootFolder.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilePath.IsSet() {
		localVarQueryParams.Add("filePath", parameterToString(localVarOptionals.FilePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CommitMsg.IsSet() {
		localVarQueryParams.Add("commitMsg", parameterToString(localVarOptionals.CommitMsg.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsNewBranch.IsSet() {
		localVarQueryParams.Add("isNewBranch", parameterToString(localVarOptionals.IsNewBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaseBranch.IsSet() {
		localVarQueryParams.Add("baseBranch", parameterToString(localVarOptionals.BaseBranch.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoOverlayInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Update Input Set for Pipeline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Input set YAML to be updated. The Account, Org, Project, and Pipeline Ids inside the YAML should match the query parameters
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline Id for the Input Set. The Input Set will work only for the Pipeline corresponding to this Id.
 * @param inputSetIdentifier Identifier for the Input Set that needs to be updated. An Input Set corresponding to this identifier should already exist.
 * @param optional nil or *InputSetsApiPutInputSetOpts - Optional Parameters:
     * @param "IfMatch" (optional.String) -  Version of entity to match
     * @param "PipelineBranch" (optional.String) -  Github branch of the Pipeline for which the Input Set is to be created
     * @param "PipelineRepoID" (optional.String) -  Github Repo Id of the Pipeline for which the Input Set is to be created
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "RootFolder" (optional.String) -  Default Folder Path
     * @param "FilePath" (optional.String) -  Default Folder Path
     * @param "CommitMsg" (optional.String) -  Commit Message
     * @param "LastObjectId" (optional.String) -  Last Object Id
     * @param "BaseBranch" (optional.String) -  Default Branch
@return ResponseDtoInputSetResponse
*/

type InputSetsApiPutInputSetOpts struct {
	IfMatch        optional.String
	PipelineBranch optional.String
	PipelineRepoID optional.String
	Branch         optional.String
	RepoIdentifier optional.String
	RootFolder     optional.String
	FilePath       optional.String
	CommitMsg      optional.String
	LastObjectId   optional.String
	BaseBranch     optional.String
}

func (a *InputSetsApiService) PutInputSet(ctx context.Context, body string, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, inputSetIdentifier string, localVarOptionals *InputSetsApiPutInputSetOpts) (ResponseDtoInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/{inputSetIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"inputSetIdentifier"+"}", fmt.Sprintf("%v", inputSetIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.PipelineBranch.IsSet() {
		localVarQueryParams.Add("pipelineBranch", parameterToString(localVarOptionals.PipelineBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PipelineRepoID.IsSet() {
		localVarQueryParams.Add("pipelineRepoID", parameterToString(localVarOptionals.PipelineRepoID.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RootFolder.IsSet() {
		localVarQueryParams.Add("rootFolder", parameterToString(localVarOptionals.RootFolder.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilePath.IsSet() {
		localVarQueryParams.Add("filePath", parameterToString(localVarOptionals.FilePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CommitMsg.IsSet() {
		localVarQueryParams.Add("commitMsg", parameterToString(localVarOptionals.CommitMsg.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastObjectId.IsSet() {
		localVarQueryParams.Add("lastObjectId", parameterToString(localVarOptionals.LastObjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaseBranch.IsSet() {
		localVarQueryParams.Add("baseBranch", parameterToString(localVarOptionals.BaseBranch.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Update an Overlay Input Set for a pipeline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Overlay Input Set YAML to be updated. The Account, Org, Project, and Pipeline identifiers inside the YAML should match the query parameters, and the Overlay Input Set identifier cannot be changed.
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline identifier for the Overlay Input Set. The Overlay Input Set will work only for the Pipeline corresponding to this identifier.
 * @param inputSetIdentifier Identifier for the Overlay Input Set that needs to be updated. An Overlay Input Set corresponding to this identifier should already exist.
 * @param optional nil or *InputSetsApiPutOverlayInputSetOpts - Optional Parameters:
     * @param "IfMatch" (optional.String) -  Version of entity to match
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "RootFolder" (optional.String) -  Default Folder Path
     * @param "FilePath" (optional.String) -  Default Folder Path
     * @param "CommitMsg" (optional.String) -  Commit Message
     * @param "LastObjectId" (optional.String) -  Last Object Id
     * @param "BaseBranch" (optional.String) -  Default Branch
@return ResponseDtoOverlayInputSetResponse
*/

type InputSetsApiPutOverlayInputSetOpts struct {
	IfMatch        optional.String
	Branch         optional.String
	RepoIdentifier optional.String
	RootFolder     optional.String
	FilePath       optional.String
	CommitMsg      optional.String
	LastObjectId   optional.String
	BaseBranch     optional.String
}

func (a *InputSetsApiService) PutOverlayInputSet(ctx context.Context, body string, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, inputSetIdentifier string, localVarOptionals *InputSetsApiPutOverlayInputSetOpts) (ResponseDtoOverlayInputSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoOverlayInputSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/overlay/{inputSetIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"inputSetIdentifier"+"}", fmt.Sprintf("%v", inputSetIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RootFolder.IsSet() {
		localVarQueryParams.Add("rootFolder", parameterToString(localVarOptionals.RootFolder.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilePath.IsSet() {
		localVarQueryParams.Add("filePath", parameterToString(localVarOptionals.FilePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CommitMsg.IsSet() {
		localVarQueryParams.Add("commitMsg", parameterToString(localVarOptionals.CommitMsg.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastObjectId.IsSet() {
		localVarQueryParams.Add("lastObjectId", parameterToString(localVarOptionals.LastObjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaseBranch.IsSet() {
		localVarQueryParams.Add("baseBranch", parameterToString(localVarOptionals.BaseBranch.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoOverlayInputSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
InputSetsApiService Fetch Runtime Input Template for a Pipeline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier Account Identifier for the entity.
 * @param orgIdentifier Organization Identifier for the entity.
 * @param projectIdentifier Project Identifier for the entity.
 * @param pipelineIdentifier Pipeline identifier for which we need the Runtime Input Template.
 * @param optional nil or *InputSetsApiRuntimeInputTemplateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of InputSetTemplateRequest) -
     * @param "Branch" (optional.String) -  Branch Name
     * @param "RepoIdentifier" (optional.String) -  Git Sync Config Id
     * @param "GetDefaultFromOtherRepo" (optional.Bool) -  if true, return all the default entities
@return ResponseDtoInputSetTemplateWithReplacedExpressionsResponse
*/

type InputSetsApiRuntimeInputTemplateOpts struct {
	Body                    optional.Interface
	Branch                  optional.String
	RepoIdentifier          optional.String
	GetDefaultFromOtherRepo optional.Bool
}

func (a *InputSetsApiService) RuntimeInputTemplate(ctx context.Context, accountIdentifier string, orgIdentifier string, projectIdentifier string, pipelineIdentifier string, localVarOptionals *InputSetsApiRuntimeInputTemplateOpts) (ResponseDtoInputSetTemplateWithReplacedExpressionsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ResponseDtoInputSetTemplateWithReplacedExpressionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pipeline/api/inputSets/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("pipelineIdentifier", parameterToString(pipelineIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetDefaultFromOtherRepo.IsSet() {
		localVarQueryParams.Add("getDefaultFromOtherRepo", parameterToString(localVarOptionals.GetDefaultFromOtherRepo.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody := localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ResponseDtoInputSetTemplateWithReplacedExpressionsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
